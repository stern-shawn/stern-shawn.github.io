{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/level-order-traversal/","webpackCompilationHash":"99ec2f49ffd060c735aa","result":{"data":{"site":{"siteMetadata":{"title":"SternJS","author":"Shawn Stern"}},"markdownRemark":{"id":"f400c68f-e8e2-5c47-ac1a-05851ed15aa3","excerpt":"Some Backstory Back in June, HackerRank was running a 30 Days of Code challenge. Thinking that this would be a perfect opportunity to brush up on the Python…","html":"<h3>Some Backstory</h3>\n<p>Back in June, <a href=\"http://www.hackerrank.com\">HackerRank</a> was running a 30 Days of Code challenge. Thinking that this would be a perfect opportunity to brush up on the Python skills that I had picked up on a rushed need-to-know-for-this-project basis over the last year or so, I signed up and committed to solving the daily problems.</p>\n<p>I’ve decided to go over a number of these challenges and my solutions going forward over the next few posts, as well as a series on some of the algorithm challenges and design projects I’ve been doing as part of the <a href=\"http://www.freecodecamp.com\">FreeCodeCamp</a> curriculum.</p>\n<h3>Getting to it</h3>\n<p>Day 23 of 30 Days of Code brought back a concept from my second intro-level CS course: binary tree traversals. However, it came with a twist. Since having learned how to apply recursion, concepts like pre-order, in-order, and post-order traversals are naturally easy to think up and recode on the spot, but this challenge was asking for an implementation of Level-Order Traversal! Having never navigated a binary tree in this way, I was excited to figure out a solution, especially since a variant of this problem comes up in Cracking the Code Interview…</p>\n<h4>What is a Level-Order Traversal anyway?</h4>\n<p>While the previously mentioned traversals typically drill down into a BST until hitting the leaf nodes, the Level-Order traversal is unique in that it visits all nodes on a given level before descending to the next deepest level. Visually, you can think of it like below where the dashed line represents our path through the example tree from left to right, top to bottom:</p>\n<p><img src=\"/5003576bae03142acb3ab5fc1d32cd12/Sorted_binary_tree_breadth-first_traversal.svg\" alt=\"BFS Diagram\"></p>\n<p>Another name for this method of navigating the data structure is a Breadth-first search, which comes up more frequently in graph theory. I sort of wish this had been introduced along with the other traversals, because it would’ve made learning BFS that much easier in my algorithms course!</p>\n<h4>That’s neat, how do we actually implement this?</h4>\n<p>This one was a challenge to start but ultimately made a ton of sense. Having done all other traversals using recursive methods, my first instinct was to also tackle this problem in the same way.</p>\n<p>After some time spent banging my head against the wall, and thinking that there was no way to do this purely recursively without some helper data structure to keep track of your position in the tree, I did some googling and ran across this pseudo-code on Wikipedia.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">levelorder<span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span>\n  q ← empty queue\n  q<span class=\"token punctuation\">.</span>enqueue<span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">not</span> q<span class=\"token punctuation\">.</span>isEmpty<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    node ← q<span class=\"token punctuation\">.</span>dequeue<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    visit<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left ≠ null<span class=\"token punctuation\">)</span>\n      q<span class=\"token punctuation\">.</span>enqueue<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right ≠ null<span class=\"token punctuation\">)</span>\n      q<span class=\"token punctuation\">.</span>enqueue<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Look at that, we aren’t even recursing! Instead, this solution relies on a First In First Out (FIFO) Queue data structure as a helper. <em>(Think of how lining up to order food works: the first person in line will reach the counter first. This is different from a Last In First Out (LIFO) Queue, which works more like an elevator: the most recent person to get in is able to get out first.)</em> If we’re given the root node, we first queue it up, pop it out, “visit” the node (in our case, we’re just printing its value), and then throw all of it’s existing children nodes into the queue, starting with the left child.</p>\n<p>Upon the next iteration of the loop, that leftmost child pops out, and the same operation occurs. Because we’re using a queue, the new child nodes of THIS current node are added to the end of the existing queue, and won’t be processed until after everything on this level, which was enqueued earlier, is visited. All without recursion!</p>\n<p>Pseudo-code and explanations in English are great, but problems are solved using real code. Let’s take a look at how I interpreted this into Python as part of a Binary Search Tree Class implementation.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> <span class=\"token function\">levelOrder</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token comment\"># Perform a level-order traversal of the given root node if possible</span>\n  <span class=\"token keyword\">if</span> root <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># Establish a 'queue' starting with root</span>\n    queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>root<span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># Iterate over the queue (walk the tree) until we empty it (we're done!)</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n      <span class=\"token comment\"># De-queue first element</span>\n      curr <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n      <span class=\"token comment\"># Print current node on same line, pad with a space</span>\n      <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span>\n\n      <span class=\"token comment\"># Enqueue any left/right children in that order</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">.</span>left <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        queue<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">.</span>right <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        queue<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span></code></pre></div>\n<p>First off, as good practice it’s smart to check if the input even exists, or is non-null in this case. This allows the code to avoid attempting to process something undefined and throwing errors.</p>\n<p>The next line, <code class=\"language-text\">queue = [root]</code>, is straightforward enough, this is where we establish the beginnings of the algorithm by initializing the queue using our definitely-not-null root node. But wait, this isn’t really a queue, persay; we’re just using a Python list since this was initialized using square brackets. Ignore that for now, I’ll explain this later!</p>\n<p><code class=\"language-text\">while(queue):</code> manages the iterative looping over the tree, and the condition of simply ‘queue’ vs having some more involved logic of determining if the queue is empty or not is just another fun feature of using the language Python. If the queue is empty, evaluating it as a boolean will return false, just the same as executing something along the lines of queue.isEmpty() in another language.</p>\n<p><code class=\"language-text\">curr = queue.pop(0)</code> is where we are able to squeeze queue-like functionality out of Python’s list data structure. By popping the element at index 0, we’re effectively dequeuing the first element and letting the remaining elements shift over by one to fill its place. In terms of absolute performance this may not be optimal, since the pop operation itself now has to shift its contents around. If I were approaching this problem with absolute performance in mind, it would be better to manually implement or import an existing queue object with pointers to the beginning and end elements that doesn’t need to readjust all of its contents on each .pop() operation. However, for my purposes of simply getting something to produce the desired output, this works perfectly and is simpler.</p>\n<p><code class=\"language-text\">print(curr.data, end=&quot; &quot;)</code> This is simply the “visiting” portion of the algorithm. One requirement of the challenge was to print the contents of the tree on a single line, with values delimited by spaces. In other languages such as Java or C which have separate print() and println() functions which print to the same line or print and move to the next line separately, this wouldn’t require much thought. However, having only experience with Python’s print() function and knowing that it always seemed to print a newline character meant I needed to find a way to call print() an undetermined number of times with a space on the end instead of a newline. Luckily, some quick research through the <a href=\"https://docs.python.org/3/tutorial/inputoutput.html\">Python documentation</a> provided a reasonable solution, the end=” ” argument which allows the coder to define an alternate end character for the print statement other than a newline character!</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">.</span>left <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  queue<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">.</span>right <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  queue<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span></code></pre></div>\n<p>The block above is pretty straightforward if you get familiar with the Python syntax (which I used earlier to check for the existence of the root node). Here, the code is checking to see if the left child node exists or not, and adding it to the queue if so. Same for the right.</p>\n<p>And that is all! If I were to run the full code on this tree below, the output would be a correct 3 2 5 1 4 7.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 320px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1f645fde6f083717059a2d748d607785/f562b/bst_example.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAd1CQL//xAAXEAEBAQEAAAAAAAAAAAAAAAABABAR/9oACAEBAAEFAm4Trf/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABsQAAICAwEAAAAAAAAAAAAAAAABESEQMUFR/9oACAEBAAE/IVWosWxYdbqeCrwY/9oADAMBAAIAAwAAABAjD//EABYRAQEBAAAAAAAAAAAAAAAAABEBEP/aAAgBAwEBPxBrn//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAAIDAQEBAAAAAAAAAAAAAAERADFBIVFh/9oACAEBAAE/ECAgGwFRVIY+ywYFZH0H0KPpCO82AYZFYJ//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Example\"\n        title=\"Example\"\n        src=\"/static/1f645fde6f083717059a2d748d607785/f562b/bst_example.jpg\"\n        srcset=\"/static/1f645fde6f083717059a2d748d607785/8ee9c/bst_example.jpg 148w,\n/static/1f645fde6f083717059a2d748d607785/ebbe7/bst_example.jpg 295w,\n/static/1f645fde6f083717059a2d748d607785/f562b/bst_example.jpg 320w\"\n        sizes=\"(max-width: 320px) 100vw, 320px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<hr>\n<p>Full source code for my solution, as well as the problem statement provided by HackerRank, can be found <a href=\"https://github.com/stern-shawn/HackerRank/tree/master/30DaysOfCode/23%20-%20BST%20Level-Order%20Traversal\">here</a>!</p>\n<hr>\n<p>Sources:</p>\n<p>[1] - Image from: <a href=\"https://en.wikipedia.org/wiki/Tree_traversal\">https://en.wikipedia.org/wiki/Tree_traversal</a></p>","frontmatter":{"title":"Digging into algorithms... Level-Order Traversals","date":"August 23, 2016","description":"Binary search tree traversals"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/level-order-traversal/","previous":{"fields":{"slug":"/hello-world/"},"frontmatter":{"title":"First Blog Post"}},"next":{"fields":{"slug":"/higher-order-components/2017-7-11-HOCs/"},"frontmatter":{"title":"Using Higher-Order Components in React"}}}}}